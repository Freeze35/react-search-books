{"ast":null,"code":"import { Reaction, _getGlobalState } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\";\nvar mobxGlobalState = _getGlobalState();\n// BC\nvar globalStateVersionIsAvailable = typeof mobxGlobalState.globalVersion !== \"undefined\";\nfunction createReaction(adm) {\n  adm.reaction = new Reaction(\"observer\".concat(adm.name), function () {\n    var _a;\n    if (!globalStateVersionIsAvailable) {\n      // BC\n      adm.stateVersion = Symbol();\n    }\n    // Force update won't be avaliable until the component \"mounts\".\n    // If state changes in between initial render and mount,\n    // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n    (_a = adm.forceUpdate) === null || _a === void 0 ? void 0 : _a.call(adm);\n  });\n}\nexport function useObserver(render, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return render();\n  }\n  var admRef = React.useRef(null);\n  if (!admRef.current) {\n    // First render\n    var adm_1 = {\n      reaction: null,\n      forceUpdate: null,\n      stateVersion: Symbol(),\n      name: baseComponentName,\n      subscribe: function subscribe(onStoreChange) {\n        // Do NOT access admRef here!\n        observerFinalizationRegistry.unregister(adm_1);\n        adm_1.forceUpdate = onStoreChange;\n        if (!adm_1.reaction) {\n          // We've lost our reaction and therefore all subscriptions.\n          // We have to recreate reaction and schedule re-render to recreate subscriptions,\n          // even if state did not change.\n          createReaction(adm_1);\n          adm_1.forceUpdate();\n        }\n        return function () {\n          var _a;\n          // Do NOT access admRef here!\n          adm_1.forceUpdate = null;\n          (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n          adm_1.reaction = null;\n        };\n      },\n      getSnapshot: function getSnapshot() {\n        // Do NOT access admRef here!\n        return globalStateVersionIsAvailable ? mobxGlobalState.stateVersion : adm_1.stateVersion;\n      }\n    };\n    admRef.current = adm_1;\n  }\n  var adm = admRef.current;\n  if (!adm.reaction) {\n    // First render or reaction was disposed by registry before subscribe\n    createReaction(adm);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    observerFinalizationRegistry.register(admRef, adm, adm);\n  }\n  React.useDebugValue(adm.reaction, printDebugValue);\n  useSyncExternalStore(\n  // Both of these must be stable, otherwise it would keep resubscribing every render.\n  adm.subscribe, adm.getSnapshot);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var renderResult;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      renderResult = render();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return renderResult;\n}","map":{"version":3,"names":["Reaction","_getGlobalState","React","printDebugValue","isUsingStaticRendering","observerFinalizationRegistry","useSyncExternalStore","mobxGlobalState","globalStateVersionIsAvailable","globalVersion","createReaction","adm","reaction","concat","name","stateVersion","Symbol","_a","forceUpdate","call","useObserver","render","baseComponentName","admRef","useRef","current","adm_1","subscribe","onStoreChange","unregister","dispose","getSnapshot","register","useDebugValue","renderResult","exception","track","e"],"sources":["D:\\T\\online-store\\search-for-books\\client\\node_modules\\mobx-react-lite\\src\\useObserver.ts"],"sourcesContent":["import { Reaction, _getGlobalState } from \"mobx\"\nimport React from \"react\"\nimport { printDebugValue } from \"./utils/printDebugValue\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\"\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\"\n\n// Do not store `admRef` (even as part of a closure!) on this object,\n// otherwise it will prevent GC and therefore reaction disposal via FinalizationRegistry.\ntype ObserverAdministration = {\n    reaction: Reaction | null // also serves as disposed flag\n    forceUpdate: Function | null // also serves as mounted flag\n    // BC: we will use local state version if global isn't available.\n    // It should behave as previous implementation - tearing is still present,\n    // because there is no cross component synchronization,\n    // but we can use `useSyncExternalStore` API.\n    stateVersion: any\n    name: string\n    // These don't depend on state/props, therefore we can keep them here instead of `useCallback`\n    subscribe: Parameters<typeof React.useSyncExternalStore>[0]\n    getSnapshot: Parameters<typeof React.useSyncExternalStore>[1]\n}\n\nconst mobxGlobalState = _getGlobalState()\n\n// BC\nconst globalStateVersionIsAvailable = typeof mobxGlobalState.globalVersion !== \"undefined\"\n\nfunction createReaction(adm: ObserverAdministration) {\n    adm.reaction = new Reaction(`observer${adm.name}`, () => {\n        if (!globalStateVersionIsAvailable) {\n            // BC\n            adm.stateVersion = Symbol()\n        }\n        // Force update won't be avaliable until the component \"mounts\".\n        // If state changes in between initial render and mount,\n        // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n        adm.forceUpdate?.()\n    })\n}\n\nexport function useObserver<T>(render: () => T, baseComponentName: string = \"observed\"): T {\n    if (isUsingStaticRendering()) {\n        return render()\n    }\n\n    const admRef = React.useRef<ObserverAdministration | null>(null)\n\n    if (!admRef.current) {\n        // First render\n        const adm: ObserverAdministration = {\n            reaction: null,\n            forceUpdate: null,\n            stateVersion: Symbol(),\n            name: baseComponentName,\n            subscribe(onStoreChange: () => void) {\n                // Do NOT access admRef here!\n                observerFinalizationRegistry.unregister(adm)\n                adm.forceUpdate = onStoreChange\n                if (!adm.reaction) {\n                    // We've lost our reaction and therefore all subscriptions.\n                    // We have to recreate reaction and schedule re-render to recreate subscriptions,\n                    // even if state did not change.\n                    createReaction(adm)\n                    adm.forceUpdate()\n                }\n\n                return () => {\n                    // Do NOT access admRef here!\n                    adm.forceUpdate = null\n                    adm.reaction?.dispose()\n                    adm.reaction = null\n                }\n            },\n            getSnapshot() {\n                // Do NOT access admRef here!\n                return globalStateVersionIsAvailable\n                    ? mobxGlobalState.stateVersion\n                    : adm.stateVersion\n            }\n        }\n\n        admRef.current = adm\n    }\n\n    const adm = admRef.current!\n\n    if (!adm.reaction) {\n        // First render or reaction was disposed by registry before subscribe\n        createReaction(adm)\n        // StrictMode/ConcurrentMode/Suspense may mean that our component is\n        // rendered and abandoned multiple times, so we need to track leaked\n        // Reactions.\n        observerFinalizationRegistry.register(admRef, adm, adm)\n    }\n\n    React.useDebugValue(adm.reaction!, printDebugValue)\n\n    useSyncExternalStore(\n        // Both of these must be stable, otherwise it would keep resubscribing every render.\n        adm.subscribe,\n        adm.getSnapshot\n    )\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let renderResult!: T\n    let exception\n    adm.reaction!.track(() => {\n        try {\n            renderResult = render()\n        } catch (e) {\n            exception = e\n        }\n    })\n\n    if (exception) {\n        throw exception // re-throw any exceptions caught during rendering\n    }\n\n    return renderResult\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}